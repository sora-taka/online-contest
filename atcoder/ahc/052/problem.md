# AtCoder Heuristic Contest 052 - Waxing Robots

## Story

CEO Takahashi of AtCoder Inc. has introduced several state-of-the-art waxing robots to improve the office environment.
He was relieved, thinking that the office floor would soon be sparkling clean, but a serious problem was quickly discovered.
Only one controller required to operate the robots had been ordered.

Normally, this would be a hopeless situation, but fortunately, the controller is equipped with an advanced "key configuration" feature.
It is a high-performance device that allows individual actions to be assigned to each button for each robot.

Takahashi has entrusted you with solving this difficult problem.
Using the limited resources available, he wants you to efficiently wax the entire office floor.

## Problem Statement

There is an N × N grid representing an office.
The coordinate of the top-left cell is (0, 0), and the coordinate of the cell i rows down and j columns to the right is (i, j).
The perimeter of the N × N grid is surrounded by walls, and there may also be walls between adjacent cells.

You are to use M robots to wax all cells.
The initial position of the k-th robot is (i_k, j_k), and including its initial position, any cell that a robot visits is considered waxed.

All robots are operated simultaneously using a single controller.
This controller has K buttons, and before starting the waxing operation, you can configure each button-robot pair to perform one of the five possible actions: move to one of the four adjacent cells (up, down, left, or right), or stay in place.
When a button is pressed, all robots simultaneously execute their respective assigned actions for that button.
Button assignments can differ between robots. For example, it is possible to configure the controller such that "on button 0, robot 0 moves up while robot 1 moves down."
Once waxing begins, the button assignments cannot be changed.

If a robot attempts to move but there is a wall between its current cell and the destination cell, it remains in place.
Robots do not interfere with each other, and multiple robots can occupy the same cell.

You may perform at most 2N² operations.
Design the button assignments and the sequence of operations so that all cells are waxed using as few operations as possible.

## Scoring

Let T (T ≤ 2N²) be the length of the output operation sequence, and let R be the number of unwaxed cells.
Your score is calculated as follows.

- If R = 0, 3N² - T
- If R > 0, N² - R

There are 150 test cases, and the score of a submission is the total score for each test case.
If your submission produces an illegal output or exceeds the time limit for some test cases, the submission itself will be judged as WA or TLE, and the score of the submission will be zero.
The highest score obtained during the contest will determine the final ranking, and there will be no system test after the contest.
If more than one participant gets the same score, they will be ranked in the same place regardless of the submission time.

## Input

Input is given from Standard Input in the following format.

```
N M K
i_0 j_0
⋮
i_{M-1} j_{M-1}
v_{0,0} ⋯ v_{0,N-2}
⋮
v_{N-1,0} ⋯ v_{N-1,N-2}
h_{0,0} ⋯ h_{0,N-1}
⋮
h_{N-2,0} ⋯ h_{N-2,N-1}
```

- In all test cases, N=30, M=10, and K=10.
- (i_k, j_k) represents the initial position of the k-th robot, and all initial positions are distinct.
- Each line v_{i,0} ⋯ v_{i,N-2} is a binary string of length N-1. The j-th character v_{i,j} indicates whether there is a wall (1) or not (0) between cell (i, j) and cell (i, j+1).
- Each line h_{i,0} ⋯ h_{i,N-1} is a binary string of length N. The j-th character h_{i,j} indicates whether there is a wall (1) or not (0) between cell (i, j) and cell (i+1, j).
- It is guaranteed that all cells are mutually reachable.

## Output

First, output the button assignments in the following format to Standard Output.

```
c_{0,0} ⋯ c_{0,M-1}
⋮
c_{K-1,0} ⋯ c_{K-1,M-1}
```

Here, c_{i,j} is a single character representing the action taken by the j-th robot when button i is pressed. It must be one of the following 5 types:

- `U`: move one cell up
- `D`: move one cell down
- `L`: move one cell left
- `R`: move one cell right
- `S`: stay in place

After that, output the operation sequence in the following format.

```
a_0
⋮
a_{T-1}
```

Here, a_t is an integer between 0 and K-1, representing the button pressed on turn t.

## Input Generation

Let rand(L, U) be a function that generates a uniformly random integer between L and U, inclusive.

The initial positions of the M robots are determined by uniformly selecting M distinct coordinates from the N² possible cells.

Walls are generated by repeating the following procedure 5 times.

1. Randomly choose the direction of the wall from up, down, left, or right.
2. Determine the wall length L = rand(10, 20).
3. For vertical walls, choose the starting point (i, j) by i = rand(5, N-5), j = rand(4, N-6).
   If the chosen j is within an absolute distance of 4 from any j used in previously generated vertical walls, redo the direction selection.
   For upward walls, set v_{i-L+1, j}, ⋯, v_{i, j} to 1. For downward walls, set v_{i, j}, ⋯, v_{i+L-1, j} to 1. Ignore any part that goes out of bounds.
4. For horizontal walls, choose the starting point (i, j) by i = rand(4, N-6), j = rand(5, N-5).
   If the chosen i is within an absolute distance of 4 from any i used in previously generated horizontal walls, redo the direction selection.
   For leftward walls, set h_{i, j-L+1}, ⋯, h_{i, j} to 1. For rightward walls, set h_{i, j}, ⋯, h_{i, j+L-1} to 1. Ignore any part that goes out of bounds.
5. After generating the wall, check whether all cells are still mutually reachable. If not, reset the wall and restart the 5 iterations.

## Sample Input 1

```
30 10 10
13 25
7 14
17 22
0 18
29 1
3 25
14 22
14 29
26 2
3 10
00000000010000000000001000000
00000000010000000000001000000
00000000010000000000001000000
00000000010000000000001000000
00000000010000000000001000000
00000000010000000000001000000
00000000010000000000001000000
00000000000000000000001000000
00000000000000000000001000000
00000000000000000000001000000
00000000000000000000001000000
00000000000000000000000000000
00000000000000000000000000000
00000000000000000000000000000
00000000000000000000000000000
00000000000000000000000000000
00000000000000000000000000000
00000000000000000000000000000
00000000000000000000000000000
00000000000000000000000000000
00000000000000010000000000000
00000000000000010000000000000
00000000000000010000000000000
00000000000000010000000000000
00000000000000010000000000000
00000000000000010000000000000
00000000000000010000000000000
00000000000000010000000000000
00000000000000010000000000000
00000000000000010000000000000
000000000000000000000000000000
000000000000000000000000000000
000000000000000000000000000000
000000000000000000000000000000
000000000000000000000000000000
000000000000000000000000000000
000000000000000000000000000000
000000000000000000000000000000
000000000000000000000000000000
000000000000000000000000000000
000000000000000000000000000000
000000000000000000000000000000
000000000000000000000000000000
000000000000000000000000000000
011111111111111111100000000000
000000000000000000000000000000
000000000000000000000000000000
000000000000000000000000000000
000000000000000000000000000000
000000000000000000000000000000
000000000000000000000000000000
000000000000000000000000000000
111111111110000000000000000000
000000000000000000000000000000
000000000000000000000000000000
000000000000000000000000000000
000000000000000000000000000000
000000000000000000000000000000
000000000000000000000000000000
```

## Sample Output 1

```
L L L R U R S D L S
R L L L D D L R D D
D S R D D S U D U R
L U S R D L S U L R
L U U L L U D U D L
L S U U S D L D U U
D D D D U D S D U S
U S U D S U L S D L
D R R R L L L S L S
L R S U S R D D R L
6
1
0
2
3
3
0
0
2
0
7
7
0
7
4
7
8
2
2
0
```